!(function(t, n) {"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t="undefined"!=typeof globalThis?globalThis:t||self).Constrainautor=n();})(this, (function() {"use strict"; const t=11102230246251565e-32; const n=134217729; const e=(3+8*t)*t; function i(t, n, e, i, r) {let s; let o; let h; let c; let f=n[0]; let u=i[0]; let a=0; let l=0; u>f==u>-f?(s=f, f=n[++a]):(s=u, u=i[++l]); let d=0; if (a<t&&l<e) {for (u>f==u>-f?(o=f+s, h=s-(o-f), f=n[++a]):(o=u+s, h=s-(o-u), u=i[++l]), s=o, 0!==h&&(r[d++]=h); a<t&&l<e;) {u>f==u>-f?(o=s+f, c=o-s, h=s-(o-c)+(f-c), f=n[++a]):(o=s+u, c=o-s, h=s-(o-c)+(u-c), u=i[++l]), s=o, 0!==h&&(r[d++]=h);}} for (;a<t;) {o=s+f, c=o-s, h=s-(o-c)+(f-c), f=n[++a], s=o, 0!==h&&(r[d++]=h);} for (;l<e;) {o=s+u, c=o-s, h=s-(o-c)+(u-c), u=i[++l], s=o, 0!==h&&(r[d++]=h);} return 0===s&&0!==d||(r[d++]=s), d;} function r(t, n, e, r, s, o, h, c) {return i(i(t, n, e, r, h), h, s, o, c);} function s(t, e, i, r) {let s; let o; let h; let c; let f; let u; let a; let l; let d; let w; let g; a=n*i, w=a-(a-i), g=i-w; let p=e[0]; s=p*i, a=n*p, l=a-(a-p), d=p-l, h=d*g-(s-l*w-d*w-l*g); let M=0; 0!==h&&(r[M++]=h); for (let E=1; E<t; E++) {p=e[E], c=p*i, a=n*p, l=a-(a-p), d=p-l, f=d*g-(c-l*w-d*w-l*g), o=s+f, u=o-s, h=s-(o-u)+(f-u), 0!==h&&(r[M++]=h), s=c+o, h=o-(s-c), 0!==h&&(r[M++]=h);} return 0===s&&0!==M||(r[M++]=s), M;} function o(t, n) {let e=n[0]; for (let i=1; i<t; i++) {e+=n[i];} return e;} function h(t) {return new Float64Array(t);} const c=h(4); const f=h(8); const u=h(12); const a=h(16); const l=h(4); function d(t, r, s, h, d, w) {const g=(r-w)*(s-d); const p=(t-d)*(h-w); const M=g-p; if (0===g||0===p||g>0!=p>0) {return M;} const E=Math.abs(g+p); return Math.abs(M)>=33306690738754716e-32*E?M:-(function(t, r, s, h, d, w, g) {let p; let M; let E; let y; let b; let x; let C; let m; let v; let A; let D; let j; let I; let T; let k; let F; let U; let q; const N=t-d; const O=s-d; const S=r-w; const V=h-w; T=N*V, x=n*N, C=x-(x-N), m=N-C, x=n*V, v=x-(x-V), A=V-v, k=m*A-(T-C*v-m*v-C*A), F=S*O, x=n*S, C=x-(x-S), m=S-C, x=n*O, v=x-(x-O), A=O-v, U=m*A-(F-C*v-m*v-C*A), D=k-U, b=k-D, c[0]=k-(D+b)+(b-U), j=T+D, b=j-T, I=T-(j-b)+(D-b), D=I-F, b=I-D, c[1]=I-(D+b)+(b-F), q=j+D, b=q-j, c[2]=j-(q-b)+(D-b), c[3]=q; let z=o(4, c); let B=22204460492503146e-32*g; if (z>=B||-z>=B) {return z;} if (b=t-N, p=t-(N+b)+(b-d), b=s-O, E=s-(O+b)+(b-d), b=r-S, M=r-(S+b)+(b-w), b=h-V, y=h-(V+b)+(b-w), 0===p&&0===M&&0===E&&0===y) {return z;} if (B=11093356479670487e-47*g+e*Math.abs(z), z+=N*y+V*p-(S*E+O*M), z>=B||-z>=B) {return z;} T=p*V, x=n*p, C=x-(x-p), m=p-C, x=n*V, v=x-(x-V), A=V-v, k=m*A-(T-C*v-m*v-C*A), F=M*O, x=n*M, C=x-(x-M), m=M-C, x=n*O, v=x-(x-O), A=O-v, U=m*A-(F-C*v-m*v-C*A), D=k-U, b=k-D, l[0]=k-(D+b)+(b-U), j=T+D, b=j-T, I=T-(j-b)+(D-b), D=I-F, b=I-D, l[1]=I-(D+b)+(b-F), q=j+D, b=q-j, l[2]=j-(q-b)+(D-b), l[3]=q; const G=i(4, c, 4, l, f); T=N*y, x=n*N, C=x-(x-N), m=N-C, x=n*y, v=x-(x-y), A=y-v, k=m*A-(T-C*v-m*v-C*A), F=S*E, x=n*S, C=x-(x-S), m=S-C, x=n*E, v=x-(x-E), A=E-v, U=m*A-(F-C*v-m*v-C*A), D=k-U, b=k-D, l[0]=k-(D+b)+(b-U), j=T+D, b=j-T, I=T-(j-b)+(D-b), D=I-F, b=I-D, l[1]=I-(D+b)+(b-F), q=j+D, b=q-j, l[2]=j-(q-b)+(D-b), l[3]=q; const H=i(G, f, 4, l, u); T=p*y, x=n*p, C=x-(x-p), m=p-C, x=n*y, v=x-(x-y), A=y-v, k=m*A-(T-C*v-m*v-C*A), F=M*E, x=n*M, C=x-(x-M), m=M-C, x=n*E, v=x-(x-E), A=E-v, U=m*A-(F-C*v-m*v-C*A), D=k-U, b=k-D, l[0]=k-(D+b)+(b-U), j=T+D, b=j-T, I=T-(j-b)+(D-b), D=I-F, b=I-D, l[1]=I-(D+b)+(b-F), q=j+D, b=q-j, l[2]=j-(q-b)+(D-b), l[3]=q; const J=i(H, u, 4, l, a); return a[J-1];})(t, r, s, h, d, w, E);} const w=h(4); const g=h(4); const p=h(4); const M=h(4); const E=h(4); const y=h(4); const b=h(4); const x=h(4); const C=h(8); const m=h(8); const v=h(8); const A=h(8); const D=h(8); const j=h(8); const I=h(8); const T=h(8); const k=h(8); const F=h(4); const U=h(4); const q=h(4); const N=h(8); const O=h(16); const S=h(16); const V=h(16); const z=h(32); const B=h(32); const G=h(48); const H=h(64); let J=h(1152); let K=h(1152); function L(t, n, e) {t=i(t, J, n, e, K); const r=J; return J=K, K=r, t;} function P(t, h, c, f, u, a, l, d) {const K=t-l; const P=c-l; const Q=u-l; const R=h-d; const W=f-d; const X=a-d; const Y=P*X; const Z=Q*W; const $=K*K+R*R; const _=Q*R; const tt=K*X; const nt=P*P+W*W; const et=K*W; const it=P*R; const rt=Q*Q+X*X; const st=$*(Y-Z)+nt*(_-tt)+rt*(et-it); const ot=(Math.abs(Y)+Math.abs(Z))*$+(Math.abs(_)+Math.abs(tt))*nt+(Math.abs(et)+Math.abs(it))*rt; const ht=11102230246251577e-31*ot; return st>ht||-st>ht?st:(function(t, h, c, f, u, a, l, d, K) {let P; let Q; let R; let W; let X; let Y; let Z; let $; let _; let tt; let nt; let et; let it; let rt; let st; let ot; let ht; let ct; let ft; let ut; let at; let lt; let dt; let wt; let gt; let pt; let Mt; let Et; let yt; let bt; let xt; let Ct; let mt; let vt; let At; const Dt=t-l; const jt=c-l; const It=u-l; const Tt=h-d; const kt=f-d; const Ft=a-d; xt=jt*Ft, dt=n*jt, wt=dt-(dt-jt), gt=jt-wt, dt=n*Ft, pt=dt-(dt-Ft), Mt=Ft-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=It*kt, dt=n*It, wt=dt-(dt-It), gt=It-wt, dt=n*kt, pt=dt-(dt-kt), Mt=kt-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, w[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, w[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, w[2]=yt-(At-lt)+(Et-lt), w[3]=At, xt=It*Tt, dt=n*It, wt=dt-(dt-It), gt=It-wt, dt=n*Tt, pt=dt-(dt-Tt), Mt=Tt-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=Dt*Ft, dt=n*Dt, wt=dt-(dt-Dt), gt=Dt-wt, dt=n*Ft, pt=dt-(dt-Ft), Mt=Ft-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, g[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, g[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, g[2]=yt-(At-lt)+(Et-lt), g[3]=At, xt=Dt*kt, dt=n*Dt, wt=dt-(dt-Dt), gt=Dt-wt, dt=n*kt, pt=dt-(dt-kt), Mt=kt-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=jt*Tt, dt=n*jt, wt=dt-(dt-jt), gt=jt-wt, dt=n*Tt, pt=dt-(dt-Tt), Mt=Tt-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, p[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, p[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, p[2]=yt-(At-lt)+(Et-lt), p[3]=At, P=i(i(i(s(s(4, w, Dt, N), N, Dt, O), O, s(s(4, w, Tt, N), N, Tt, S), S, z), z, i(s(s(4, g, jt, N), N, jt, O), O, s(s(4, g, kt, N), N, kt, S), S, B), B, H), H, i(s(s(4, p, It, N), N, It, O), O, s(s(4, p, Ft, N), N, Ft, S), S, z), z, J); let Ut=o(P, J); let qt=4440892098500632e-31*K; if (Ut>=qt||-Ut>=qt) {return Ut;} if (lt=t-Dt, Q=t-(Dt+lt)+(lt-l), lt=h-Tt, X=h-(Tt+lt)+(lt-d), lt=c-jt, R=c-(jt+lt)+(lt-l), lt=f-kt, Y=f-(kt+lt)+(lt-d), lt=u-It, W=u-(It+lt)+(lt-l), lt=a-Ft, Z=a-(Ft+lt)+(lt-d), 0===Q&&0===R&&0===W&&0===X&&0===Y&&0===Z) {return Ut;} if (qt=5423418723394464e-46*K+e*Math.abs(Ut), Ut+=(Dt*Dt+Tt*Tt)*(jt*Z+Ft*R-(kt*W+It*Y))+2*(Dt*Q+Tt*X)*(jt*Ft-kt*It)+((jt*jt+kt*kt)*(It*X+Tt*W-(Ft*Q+Dt*Z))+2*(jt*R+kt*Y)*(It*Tt-Ft*Dt))+((It*It+Ft*Ft)*(Dt*Y+kt*Q-(Tt*R+jt*X))+2*(It*W+Ft*Z)*(Dt*kt-Tt*jt)), Ut>=qt||-Ut>=qt) {return Ut;} if (0===R&&0===Y&&0===W&&0===Z||(xt=Dt*Dt, dt=n*Dt, wt=dt-(dt-Dt), gt=Dt-wt, Ct=gt*gt-(xt-wt*wt-(wt+wt)*gt), mt=Tt*Tt, dt=n*Tt, wt=dt-(dt-Tt), gt=Tt-wt, vt=gt*gt-(mt-wt*wt-(wt+wt)*gt), Et=Ct+vt, lt=Et-Ct, M[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, M[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, M[2]=yt-(At-lt)+(Et-lt), M[3]=At), 0===W&&0===Z&&0===Q&&0===X||(xt=jt*jt, dt=n*jt, wt=dt-(dt-jt), gt=jt-wt, Ct=gt*gt-(xt-wt*wt-(wt+wt)*gt), mt=kt*kt, dt=n*kt, wt=dt-(dt-kt), gt=kt-wt, vt=gt*gt-(mt-wt*wt-(wt+wt)*gt), Et=Ct+vt, lt=Et-Ct, E[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, E[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, E[2]=yt-(At-lt)+(Et-lt), E[3]=At), 0===Q&&0===X&&0===R&&0===Y||(xt=It*It, dt=n*It, wt=dt-(dt-It), gt=It-wt, Ct=gt*gt-(xt-wt*wt-(wt+wt)*gt), mt=Ft*Ft, dt=n*Ft, wt=dt-(dt-Ft), gt=Ft-wt, vt=gt*gt-(mt-wt*wt-(wt+wt)*gt), Et=Ct+vt, lt=Et-Ct, y[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, y[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, y[2]=yt-(At-lt)+(Et-lt), y[3]=At), 0!==Q&&($=s(4, w, Q, C), P=L(P, r(s($, C, 2*Dt, O), O, s(s(4, y, Q, N), N, kt, S), S, s(s(4, E, Q, N), N, -Ft, V), V, z, G), G)), 0!==X&&(_=s(4, w, X, m), P=L(P, r(s(_, m, 2*Tt, O), O, s(s(4, E, X, N), N, It, S), S, s(s(4, y, X, N), N, -jt, V), V, z, G), G)), 0!==R&&(tt=s(4, g, R, v), P=L(P, r(s(tt, v, 2*jt, O), O, s(s(4, M, R, N), N, Ft, S), S, s(s(4, y, R, N), N, -Tt, V), V, z, G), G)), 0!==Y&&(nt=s(4, g, Y, A), P=L(P, r(s(nt, A, 2*kt, O), O, s(s(4, y, Y, N), N, Dt, S), S, s(s(4, M, Y, N), N, -It, V), V, z, G), G)), 0!==W&&(et=s(4, p, W, D), P=L(P, r(s(et, D, 2*It, O), O, s(s(4, E, W, N), N, Tt, S), S, s(s(4, M, W, N), N, -kt, V), V, z, G), G)), 0!==Z&&(it=s(4, p, Z, j), P=L(P, r(s(it, j, 2*Ft, O), O, s(s(4, M, Z, N), N, jt, S), S, s(s(4, E, Z, N), N, -Dt, V), V, z, G), G)), 0!==Q||0!==X) {if (0!==R||0!==Y||0!==W||0!==Z?(xt=R*Ft, dt=n*R, wt=dt-(dt-R), gt=R-wt, dt=n*Ft, pt=dt-(dt-Ft), Mt=Ft-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=jt*Z, dt=n*jt, wt=dt-(dt-jt), gt=jt-wt, dt=n*Z, pt=dt-(dt-Z), Mt=Z-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, b[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, b[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, b[2]=yt-(At-lt)+(Et-lt), b[3]=At, xt=W*-kt, dt=n*W, wt=dt-(dt-W), gt=W-wt, dt=n*-kt, pt=dt-(dt- -kt), Mt=-kt-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=It*-Y, dt=n*It, wt=dt-(dt-It), gt=It-wt, dt=n*-Y, pt=dt-(dt- -Y), Mt=-Y-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, x[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, x[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, x[2]=yt-(At-lt)+(Et-lt), x[3]=At, st=i(4, b, 4, x, T), xt=R*Z, dt=n*R, wt=dt-(dt-R), gt=R-wt, dt=n*Z, pt=dt-(dt-Z), Mt=Z-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=W*Y, dt=n*W, wt=dt-(dt-W), gt=W-wt, dt=n*Y, pt=dt-(dt-Y), Mt=Y-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, U[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, U[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, U[2]=yt-(At-lt)+(Et-lt), U[3]=At, ct=4):(T[0]=0, st=1, U[0]=0, ct=1), 0!==Q) {const t=s(st, T, Q, V); P=L(P, i(s($, C, Q, O), O, s(t, V, 2*Dt, z), z, G), G); const n=s(ct, U, Q, N); P=L(P, r(s(n, N, 2*Dt, O), O, s(n, N, Q, S), S, s(t, V, Q, z), z, B, H), H), 0!==Y&&(P=L(P, s(s(4, y, Q, N), N, Y, O), O)), 0!==Z&&(P=L(P, s(s(4, E, -Q, N), N, Z, O), O));} if (0!==X) {const t=s(st, T, X, V); P=L(P, i(s(_, m, X, O), O, s(t, V, 2*Tt, z), z, G), G); const n=s(ct, U, X, N); P=L(P, r(s(n, N, 2*Tt, O), O, s(n, N, X, S), S, s(t, V, X, z), z, B, H), H);}} if (0!==R||0!==Y) {if (0!==W||0!==Z||0!==Q||0!==X?(xt=W*Tt, dt=n*W, wt=dt-(dt-W), gt=W-wt, dt=n*Tt, pt=dt-(dt-Tt), Mt=Tt-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=It*X, dt=n*It, wt=dt-(dt-It), gt=It-wt, dt=n*X, pt=dt-(dt-X), Mt=X-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, b[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, b[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, b[2]=yt-(At-lt)+(Et-lt), b[3]=At, ut=-Ft, at=-Z, xt=Q*ut, dt=n*Q, wt=dt-(dt-Q), gt=Q-wt, dt=n*ut, pt=dt-(dt-ut), Mt=ut-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=Dt*at, dt=n*Dt, wt=dt-(dt-Dt), gt=Dt-wt, dt=n*at, pt=dt-(dt-at), Mt=at-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, x[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, x[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, x[2]=yt-(At-lt)+(Et-lt), x[3]=At, ot=i(4, b, 4, x, k), xt=W*X, dt=n*W, wt=dt-(dt-W), gt=W-wt, dt=n*X, pt=dt-(dt-X), Mt=X-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=Q*Z, dt=n*Q, wt=dt-(dt-Q), gt=Q-wt, dt=n*Z, pt=dt-(dt-Z), Mt=Z-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, q[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, q[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, q[2]=yt-(At-lt)+(Et-lt), q[3]=At, ft=4):(k[0]=0, ot=1, q[0]=0, ft=1), 0!==R) {const t=s(ot, k, R, V); P=L(P, i(s(tt, v, R, O), O, s(t, V, 2*jt, z), z, G), G); const n=s(ft, q, R, N); P=L(P, r(s(n, N, 2*jt, O), O, s(n, N, R, S), S, s(t, V, R, z), z, B, H), H), 0!==Z&&(P=L(P, s(s(4, M, R, N), N, Z, O), O)), 0!==X&&(P=L(P, s(s(4, y, -R, N), N, X, O), O));} if (0!==Y) {const t=s(ot, k, Y, V); P=L(P, i(s(nt, A, Y, O), O, s(t, V, 2*kt, z), z, G), G); const n=s(ft, q, Y, N); P=L(P, r(s(n, N, 2*kt, O), O, s(n, N, Y, S), S, s(t, V, Y, z), z, B, H), H);}} if (0!==W||0!==Z) {if (0!==Q||0!==X||0!==R||0!==Y?(xt=Q*kt, dt=n*Q, wt=dt-(dt-Q), gt=Q-wt, dt=n*kt, pt=dt-(dt-kt), Mt=kt-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=Dt*Y, dt=n*Dt, wt=dt-(dt-Dt), gt=Dt-wt, dt=n*Y, pt=dt-(dt-Y), Mt=Y-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, b[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, b[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, b[2]=yt-(At-lt)+(Et-lt), b[3]=At, ut=-Tt, at=-X, xt=R*ut, dt=n*R, wt=dt-(dt-R), gt=R-wt, dt=n*ut, pt=dt-(dt-ut), Mt=ut-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=jt*at, dt=n*jt, wt=dt-(dt-jt), gt=jt-wt, dt=n*at, pt=dt-(dt-at), Mt=at-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct+vt, lt=Et-Ct, x[0]=Ct-(Et-lt)+(vt-lt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt+mt, lt=Et-bt, x[1]=bt-(Et-lt)+(mt-lt), At=yt+Et, lt=At-yt, x[2]=yt-(At-lt)+(Et-lt), x[3]=At, rt=i(4, b, 4, x, I), xt=Q*Y, dt=n*Q, wt=dt-(dt-Q), gt=Q-wt, dt=n*Y, pt=dt-(dt-Y), Mt=Y-pt, Ct=gt*Mt-(xt-wt*pt-gt*pt-wt*Mt), mt=R*X, dt=n*R, wt=dt-(dt-R), gt=R-wt, dt=n*X, pt=dt-(dt-X), Mt=X-pt, vt=gt*Mt-(mt-wt*pt-gt*pt-wt*Mt), Et=Ct-vt, lt=Ct-Et, F[0]=Ct-(Et+lt)+(lt-vt), yt=xt+Et, lt=yt-xt, bt=xt-(yt-lt)+(Et-lt), Et=bt-mt, lt=bt-Et, F[1]=bt-(Et+lt)+(lt-mt), At=yt+Et, lt=At-yt, F[2]=yt-(At-lt)+(Et-lt), F[3]=At, ht=4):(I[0]=0, rt=1, F[0]=0, ht=1), 0!==W) {const t=s(rt, I, W, V); P=L(P, i(s(et, D, W, O), O, s(t, V, 2*It, z), z, G), G); const n=s(ht, F, W, N); P=L(P, r(s(n, N, 2*It, O), O, s(n, N, W, S), S, s(t, V, W, z), z, B, H), H), 0!==X&&(P=L(P, s(s(4, E, W, N), N, X, O), O)), 0!==Y&&(P=L(P, s(s(4, M, -W, N), N, Y, O), O));} if (0!==Z) {const t=s(rt, I, Z, V); P=L(P, i(s(it, j, Z, O), O, s(t, V, 2*Ft, z), z, G), G); const n=s(ht, F, Z, N); P=L(P, r(s(n, N, 2*Ft, O), O, s(n, N, Z, S), S, s(t, V, Z, z), z, B, H), H);}} return J[P-1];})(t, h, c, f, u, a, l, d, ot);} class Q extends class {constructor(t, n) {this.W=t, this.bs=n;}

  add(t) {const n=this.W; const e=t/n|0; const i=t%n; return this.bs[e]|=1<<i, this;}

  delete(t) {const n=this.W; const e=t/n|0; const i=t%n; return this.bs[e]&=~(1<<i), this;}

  set(t, n) {const e=this.W; const i=t/e|0; const r=1<<t%e; return this.bs[i]^=(-n^this.bs[i])&r, n;}

  has(t) {const n=this.W; const e=t/n|0; const i=t%n; return !!(this.bs[e]&1<<i);}

  forEach(t) {const n=this.W; const e=this.bs; const i=e.length; for (let r=0; r<i; r++) {let i=0; for (;e[r]&&i<n;) {e[r]&1<<i&&t(r*n+i), i++;}} return this;}} {constructor(t) {super(8, new Uint8Array(Math.ceil(t/8)).fill(0));}} function R(t) {return t%3==2?t-2:t+1;} function W(t) {return t%3==0?t+2:t-1;} class X {constructor(t, n) {if (!(t&&"object"==typeof t&&t.triangles&&t.halfedges&&t.coords)) {throw new Error("Expected an object with Delaunator output");} if (t.triangles.length%3||t.halfedges.length!==t.triangles.length||t.coords.length%2) {throw new Error("Delaunator output appears inconsistent");} if (t.triangles.length<3) {throw new Error("No edges in triangulation");} this.del=t; const e=2**32-1; const i=t.coords.length>>1; const r=t.triangles.length; this.t=new Uint32Array(i).fill(e), this.i=new Q(r), this.o=new Q(r); for (let n=0; n<r; n++) {const i=t.triangles[n]; this.t[i]===e&&this.h(n);}n&&this.constrainAll(n);}

  constrainOne(t, n) {const {triangles: e, halfedges: i}=this.del; const r=this.t; const s=this.o; const o=r[t]; let h=o; do {const r=e[h]; const s=R(h); if (r===n) {return this.u(h);} const o=W(h); const c=e[o]; if (c===n) {return this.u(s), s;} if (this.intersectSegments(t, n, c, r)) {h=o; break;}h=i[s];} while (-1!==h&&h!==o); let c=h; let f=-1; for (;-1!==h;) {const r=i[h]; const o=W(h); const u=W(r); const a=R(r); if (-1===r) {throw new Error("Constraining edge exited the hull");} if (s.has(h)) {throw new Error("Edge intersects already constrained edge");} if (this.isCollinear(t, n, e[h])||this.isCollinear(t, n, e[r])) {throw new Error("Constraining edge intersects point");} if (this.intersectSegments(e[h], e[r], e[o], e[u])) {if (this.l(h), this.intersectSegments(t, n, e[o], e[u])&&(-1===f&&(f=o), f===o)) {throw new Error("Infinite loop: flipped diagonal still intersects");} e[u]===n?(c=u, h=f, f=-1):this.intersectSegments(t, n, e[a], e[u])&&(h=a);} else {if (-1===f&&(f=h), e[u]===n) {if (h===f) {throw new Error("Infinite loop: non-convex quadrilateral");} h=f, f=-1; continue;} if (this.intersectSegments(t, n, e[u], e[r])) {h=u;} else if (this.intersectSegments(t, n, e[a], e[u])) {h=a;} else if (f===h) {throw new Error("Infinite loop: no further intersect after non-convex");}}} const u=this.i; this.u(c); do {var a=0; u.forEach((t => {u.delete(t); const n=i[t]; -1!==n&&(u.delete(n), this.g(t)||(this.l(t), a++));}));} while (a>0); return this.findEdge(t, n);}

  delaunify(t=!1) {const n=this.del.halfedges; const e=this.i; const i=this.o; const r=n.length; do {var s=0; for (let t=0; t<r; t++) {if (i.has(t)) {continue;} e.delete(t); const r=n[t]; -1!==r&&(e.delete(r), this.g(t)||(this.l(t), s++));}} while (t&&s>0); return this;}

  constrainAll(t) {const n=t.length; for (let e=0; e<n; e++) {const n=t[e]; this.constrainOne(n[0], n[1]);} return this;}

  isConstrained(t) {return this.o.has(t);}

  findEdge(t, n) {const e=this.t[n]; const {triangles: i, halfedges: r}=this.del; let s=e; let o=-1; do {if (i[s]===t) {return s;} o=R(s), s=r[o];} while (-1!==s&&s!==e); return i[R(o)]===t?-o:1/0;}

  u(t) {const n=this.del.halfedges[t]; const e=this.i; const i=this.o; return e.delete(t), i.add(t), -1!==n?(e.delete(n), i.add(n), n):-t;}

  p(t) {const n=this.del.halfedges; const e=this.i; if (this.o.has(t)) {return !1;} const i=n[t]; return -1!==i&&(e.add(t), e.add(i)), !0;}

  l(t) {const {triangles: n, halfedges: e}=this.del; const i=this.i; const r=this.o; const s=e[t]; const o=W(t); const h=R(t); const c=W(s); const f=R(s); const u=e[o]; const a=e[c]; if (r.has(t)) {throw new Error("Trying to flip a constrained edge");} return n[t]=n[c], e[t]=a, i.set(t, i.has(c))||r.set(t, r.has(c)), -1!==a&&(e[a]=t), e[o]=c, n[s]=n[o], e[s]=u, i.set(s, i.has(o))||r.set(s, r.has(o)), -1!==u&&(e[u]=s), e[c]=o, this.p(t), this.p(h), this.p(s), this.p(f), i.add(o), r.delete(o), i.add(c), r.delete(c), this.h(t), this.h(h), this.h(s), this.h(f), o;}

  g(t) {const {triangles: n, halfedges: e}=this.del; const i=e[t]; if (-1===i) {return !0;} const r=n[W(t)]; const s=n[t]; const o=n[R(t)]; const h=n[W(i)]; return !this.inCircle(r, s, o, h);}

  h(t) {const {triangles: n, halfedges: e}=this.del; const i=this.t; const r=n[t]; let s=W(t); let o=e[s]; for (;-1!==o&&o!==t;) {s=W(o), o=e[s];} return i[r]=s, s;}

  intersectSegments(t, n, e, i) {const r=this.del.coords; return t!==e&&t!==i&&n!==e&&n!==i&&Y(r[2*t], r[2*t+1], r[2*n], r[2*n+1], r[2*e], r[2*e+1], r[2*i], r[2*i+1]);}

  inCircle(t, n, e, i) {const r=this.del.coords; return P(r[2*t], r[2*t+1], r[2*n], r[2*n+1], r[2*e], r[2*e+1], r[2*i], r[2*i+1])<0;}

  isCollinear(t, n, e) {const i=this.del.coords; return 0===d(i[2*t], i[2*t+1], i[2*n], i[2*n+1], i[2*e], i[2*e+1]);}} function Y(t, n, e, i, r, s, o, h) {const c=d(t, n, r, s, o, h); const f=d(e, i, r, s, o, h); if (c>0&&f>0||c<0&&f<0) {return !1;} const u=d(r, s, t, n, e, i); const a=d(o, h, t, n, e, i); return !(u>0&&a>0||u<0&&a<0)&&(0!==c||0!==f||0!==u||0!==a||!(Math.max(r, o)<Math.min(t, e)||Math.max(t, e)<Math.min(r, o)||Math.max(s, h)<Math.min(n, i)||Math.max(n, i)<Math.min(s, h)));} return X.intersectSegments=Y, X;}));
